/* This is to make emacs edit this in C mode: -*-C-*- */
#line 2 "compiler/post"

static void insert_pop_value PROT((void));
static void prolog PROT((void));
static void epilog PROT((void));
static void clean_parser PROT((void));

#ifdef LPC_OPTIMIZE_LOOPS
static int optimize_loop_cond PROT((char *e, int len));
static int optimize_while_dec PROT((char *e, int len));
#endif
void yyerror P1(char *, str)
{
    extern int num_parse_error;

    if (num_parse_error > 5)
	return;
    (void)fprintf(stderr, "%s: %s line %d\n", current_file, str,
	  current_line);
    fflush(stderr);
    smart_log(current_file, current_line, str,0);
#ifndef NO_MUDLIB_STATS
    add_errors_for_file (current_file, 1);
#endif
    num_parse_error++;
}

int add_local_name P2(char *, str, int, type)
{
    if (current_number_of_locals == MAX_LOCAL) {
	yyerror("Too many local variables");
	return 0;
    } else {
	type_of_locals[current_number_of_locals] = type;
	local_names[current_number_of_locals] = str;
	return (current_number_of_locals++);
    }
}

/*
 * This function is called from lex.c for every new line read from the
 * "top" file (means not included files). Some new lines are missed,
 * as with #include statements, so it is compensated for.
 */
void store_line_number_info()
{
    unsigned short offset = mem_block[A_PROGRAM].current_size;

    while (mem_block[A_LINENUMBERS].current_size / sizeof (short) <
	  current_line) {
	add_to_mem_block(A_LINENUMBERS, (char *)&offset, sizeof offset);
    }
}

/*
 * Compile an LPC file.
 */
void compile_file() {
    int yyparse PROT((void));

    prolog();
    yyparse();
    epilog();
}

int get_id_number() {
    static int current_id_number = 1;
    return current_id_number++;
}

/*
 * The program has been compiled. Prepare a 'struct program' to be returned.
 */
static void epilog() {
    int size, i;
    char *p;
    struct function *funp;
    void save_binary PROT((struct program *prog, struct mem_block *includes,
	  struct mem_block *patches));

    if (num_parse_error > 0 || inherit_file) {
	clean_parser();
	return;
    }

#ifdef DEBUG
    if (type_of_arguments.current_size != 0)
	fatal("Failed to deallocate argument type stack\n");
#endif
    /*
     * Define the __INIT function, but only if there was any code
     * to initialize.
     */
    if (mem_block[A_INITIALIZER].current_size) {
	/* end the __INIT function */
	current_block = A_INITIALIZER;
	ins_f_byte(F_CONST0);
	ins_f_byte(F_RETURN);
	define_new_function("__INIT", 0, 0, 0, 0, 0);

	/* add the jump to the function body */
	current_block = A_PROGRAM;
	upd_short(1, CURRENT_PROGRAM_SIZE);
	add_to_mem_block(A_PROGRAM, (char *)mem_block[A_INITIALIZER].block,
	                            mem_block[A_INITIALIZER].current_size);
    }

    /*
     * If functions are undefined, replace them by definitions done
     * by inheritance. All explicit "name::func" are already resolved.
     */
    for (i = 0; i < mem_block[A_FUNCTIONS].current_size; i += sizeof *funp) {
	funp = (struct function *)(mem_block[A_FUNCTIONS].block + i);
	if (!(funp->flags & NAME_UNDEFINED))
	    continue;
	if (!find_in_table(funp, i)) { /* enforce proper M.I. semantics */
	    find_inherited(funp);
	}
    }

    size = align(sizeof (struct program));
    for (i=0; i<NUMPAREAS; i++)
	if (i != A_LINENUMBERS && i != A_ARGUMENT_TYPES && i != A_ARGUMENT_INDEX)
	    size += align(mem_block[i].current_size);
    p = (char *)DXALLOC(size, 56, "epilog: 1");
    prog = (struct program *)p;
    *prog = NULL_program;
    prog->p.i.total_size = size;
    prog->p.i.ref = 0;
    prog->p.i.heart_beat = heart_beat;
    prog->name = string_copy(current_file);
    prog->p.i.id_number = get_id_number();
    total_prog_block_size += prog->p.i.total_size;
    total_num_prog_blocks += 1;

    prog->p.i.line_swap_index = -1;
    prog->p.i.line_numbers = (unsigned short *)
	  XALLOC(mem_block[A_LINENUMBERS].current_size + sizeof(short));
    memcpy(((char*)&prog->p.i.line_numbers[1]),
	  mem_block[A_LINENUMBERS].block,
	  mem_block[A_LINENUMBERS].current_size);
    prog->p.i.line_numbers[0] =
	  (mem_block[A_LINENUMBERS].current_size / sizeof(short)) + 1;

    p += align(sizeof (struct program));
    prog->p.i.program = p;
    if (mem_block[A_PROGRAM].current_size)
	memcpy(p, mem_block[A_PROGRAM].block,
	      mem_block[A_PROGRAM].current_size);
    prog->p.i.program_size = mem_block[A_PROGRAM].current_size;

    p += align(mem_block[A_PROGRAM].current_size);
    prog->p.i.functions = (struct function *)p;
    prog->p.i.num_functions = mem_block[A_FUNCTIONS].current_size /
	  sizeof (struct function);
    if (mem_block[A_FUNCTIONS].current_size)
	memcpy(p, mem_block[A_FUNCTIONS].block,
	      mem_block[A_FUNCTIONS].current_size);

#ifdef OPTIMIZE_FUNCTION_TABLE_SEARCH
    prog->p.i.tree_r = a_functions_root;
#endif

    p += align(mem_block[A_FUNCTIONS].current_size);
    prog->p.i.strings = (char **)p;
    prog->p.i.num_strings = mem_block[A_STRINGS].current_size /
	  sizeof (char *);
    if (mem_block[A_STRINGS].current_size)
	memcpy(p, mem_block[A_STRINGS].block,
	      mem_block[A_STRINGS].current_size);

    p += align(mem_block[A_STRINGS].current_size);
    prog->p.i.variable_names = (struct variable *)p;
    prog->p.i.num_variables = mem_block[A_VARIABLES].current_size /
	  sizeof (struct variable);
    if (mem_block[A_VARIABLES].current_size)
	memcpy(p, mem_block[A_VARIABLES].block,
	      mem_block[A_VARIABLES].current_size);

    p += align(mem_block[A_VARIABLES].current_size);
    prog->p.i.num_inherited = mem_block[A_INHERITS].current_size /
	  sizeof (struct inherit);
    if (prog->p.i.num_inherited) {
	memcpy(p, mem_block[A_INHERITS].block,
	      mem_block[A_INHERITS].current_size);
	prog->p.i.inherit = (struct inherit *)p;
    } else
	prog->p.i.inherit = 0;

    prog->p.i.argument_types = 0;       /* For now. Will be fixed someday */
    prog->p.i.type_start = 0;

#ifdef SAVE_BINARIES
#ifdef ALWAYS_SAVE_BINARIES
    save_binary(prog, &mem_block[A_INCLUDES], &mem_block[A_PATCH]);
#else
    if (pragma_save_binaries) {
	save_binary(prog, &mem_block[A_INCLUDES], &mem_block[A_PATCH]);
    }
#endif
#endif

    swap_line_numbers(prog); /* do this after saving binary */

    for (i=0; i<NUMAREAS; i++)
	FREE((char *)mem_block[i].block);

    /*  marion
	Do referencing here - avoid multiple referencing when an object
	inherits more than one object and one of the inherited is already
	loaded and not the last inherited
    */
    reference_prog (prog, "epilog");
    for (i = 0; (unsigned)i < prog->p.i.num_inherited; i++) {
	reference_prog (prog->p.i.inherit[i].prog, "inheritance");
    }
}

/*
 * Initialize the environment that the compiler needs.
 */
static void prolog() {
    int i;
    void free_expressions();

    current_block = A_PROGRAM;
    switches = 0;
    switch_sptr = 0;
    last_expression = -1;
    free_expressions();
    if (type_of_arguments.block == 0) {
	type_of_arguments.max_size = 100;
	type_of_arguments.block =
	      DXALLOC(type_of_arguments.max_size, 57, "prolog: 1");
    }
    type_of_arguments.current_size = 0;
    approved_object = 0;
    last_push_indexed = -1;
    last_push_local = -1;
    last_push_identifier = -1;
    prog = 0;   /* 0 means fail to load. */
    heart_beat = -1;
    comp_stackp = 0;    /* Local temp stack used by compiler */
    current_continue_address = 0;
    current_break_address = 0;
    num_parse_error = 0;
    free_all_local_names();     /* In case of earlier error */
#ifdef OPTIMIZE_FUNCTION_TABLE_SEARCH
    a_functions_root = (unsigned short)0xffff;
#endif
    /* Initialize memory blocks where the result of the compilation
     * will be stored.
     */
    for (i=0; i < NUMAREAS; i++) {
	mem_block[i].block = DXALLOC(START_BLOCK_SIZE, 58, "prolog: 2");
	mem_block[i].current_size = 0;
	mem_block[i].max_size = START_BLOCK_SIZE;
    }
    memset(string_tags, 0, sizeof(string_tags));
    freed_string = -1;
    current_block = A_PROGRAM;
    ins_f_byte(F_JUMP);
    ins_short(0);
}

/*
 * The program has errors, clean things up.
 */
static void clean_parser() {
    int i;
    struct function *funp;
    struct variable dummy;
    char *s;

    /*
     * Free function stuff.
     */
    for (i = 0; i < mem_block[A_FUNCTIONS].current_size; i += sizeof *funp) {
	funp = (struct function *)(mem_block[A_FUNCTIONS].block + i);
	if (funp->name)
	    free_string(funp->name);
    }
    for (i = 0; i < mem_block[A_STRINGS].current_size; i += sizeof(char *)) {
	((char *)&s)[0] = mem_block[A_STRINGS].block[i + 0];
	((char *)&s)[1] = mem_block[A_STRINGS].block[i + 1];
	((char *)&s)[2] = mem_block[A_STRINGS].block[i + 2];
	((char *)&s)[3] = mem_block[A_STRINGS].block[i + 3];
	free_string(s);
    }
    for (i = 0; i < mem_block[A_VARIABLES].current_size; i += sizeof dummy) {
	memcpy(&dummy, mem_block[A_VARIABLES].block + i, sizeof dummy);
	free_string(dummy.name);
    }

    prog = 0;
    for (i=0; i<NUMAREAS; i++)
	FREE(mem_block[i].block);
    if (num_parse_error)
	smart_log (NULL,0,NULL,1);
}

/*
   push_switches should be called at the beginning of the parsing of
   any loop construct.
*/

static void
push_switches()
{
#ifdef DEBUG
    if (switch_sptr == SWITCH_STACK_SIZE) {
	fatal("switch_stack overflow\n");
    }
#endif
    switch_stack[switch_sptr++] = switches;
    switches = 0;
}

/*
   pop_switches should be called at the end of the parsing of any loop
   construct.
*/

static void
pop_switches()
{
#ifdef DEBUG
    if (switch_sptr == 0) {
       fatal("switch_stack underflow\n");
    }
#endif
    switches = switch_stack[--switch_sptr];
}

static void
push_expression P1(expr_t *, e)
{
#ifdef DEBUG
    if (expr_sptr == EXPR_STACK_SIZE) {
	fatal("expr_stack overflow\n");
    }
#endif
    memcpy(&expr_stack[expr_sptr++], e, sizeof(expr_t));
}

static expr_t *
pop_expression()
{
#ifdef DEBUG
    if (expr_sptr == 0) {
       fatal("expr_stack underflow\n");
    }
#endif
	return &expr_stack[--expr_sptr];
}

/* this only necessary in case of errors in compiling LPC code */
static void
free_expressions()
{
    int j;

    for (j = 0; j < expr_sptr; j++) {
	if (expr_stack[j].expr) {
	    FREE(expr_stack[j].expr);
	}
    }
    expr_sptr = 0;
}

char *
the_file_name P1(char *, name)
{
    char *tmp;
    int len;

    len = strlen(name);
    if (len < 3) {
	return string_copy(name);
    }
    tmp = (char *)DXALLOC(len, 59, "the_file_name");
    if (!tmp) {
	return string_copy(name);
    }
    strcpy(tmp, "/");
    strncpy(tmp + 1, name, len - 2);
    tmp[len - 1] = '\0';
    return tmp;
}

static void
insert_pop_value()
{
    if (last_expression == CURRENT_PROGRAM_SIZE-1) {
	switch ( LAST_EXPR_CODE ) {
	    case F_ASSIGN:
		mem_block[A_PROGRAM].block[last_expression] =
		      F_VOID_ASSIGN;
		break;
	    case F_ADD_EQ:
		mem_block[A_PROGRAM].block[last_expression] =
		      F_VOID_ADD_EQ;
		break;
	    case F_PRE_INC:
	    case F_POST_INC:
		mem_block[A_PROGRAM].block[last_expression] =
		      F_INC;
		break;
	    case F_PRE_DEC:
	    case F_POST_DEC:
		mem_block[A_PROGRAM].block[last_expression] =
		      F_DEC;
		break;
	    case F_CONST0:
	    case F_CONST1:
		SET_CURRENT_PROGRAM_SIZE(last_expression);
		break;
	    default: ins_f_byte(F_POP_VALUE);
		break;
	}
	last_expression = -1;
    } else {
	ins_f_byte(F_POP_VALUE);
    }
}

#ifdef LPC_OPTIMIZE_LOOPS
/* peephole optimization on the middle for_expr and while loop conditions. */

static int
optimize_loop_cond P2(char *, e, int, len)
{
    if ((len == 5) && (e[0] == F_LOCAL_NAME) && (e[2] == F_LOCAL_NAME)
	  && (e[4] == F_LT) && (e[5] == F_BBRANCH_WHEN_NON_ZERO)) {
	e[0] = F_LOOP_COND;
	return 1;
    }
    if ((len == 8) && (e[0] == F_LOCAL_NAME) && (e[2] == F_NUMBER)
	  && (e[7] == F_LT) && (e[8] == F_BBRANCH_WHEN_NON_ZERO)) {
	e[0] = F_LOOP_COND;
	return 1;
    }
    return 0;
}

/* peephole optimization on the middle for_expr and while loop conditions. */

static int
optimize_while_dec P2(char *, e, int, len)
{
    if ((len == 3) && (e[0] == F_PUSH_LOCAL_VARIABLE_LVALUE)
	  && (e[2] == F_POST_DEC) && (e[3] == F_BBRANCH_WHEN_NON_ZERO)) {
	e[0] = F_WHILE_DEC;
	return 1;
    }
    return 0;
}
#endif

/*
 * Save a list of all the include files.  This is so we can
 * tell if a saved binary is out of date or not.  In the future,
 * may be used to give better line numbers for errors.
 */
void
save_include P1(char *, name)
{
    /* at the moment, only used for binaries, so ifdef out */
#ifdef SAVE_BINARIES
    extern int pragma_save_binaries;

    if (pragma_save_binaries) {
	add_to_mem_block(A_INCLUDES, name, strlen(name)+1);
    }
#endif
}
