%{  /* This is to make emacs edit this in C mode: -*-C-*- */
#include "compiler_shared.h"
#include "opcodes.h"

#line 6 "compiler/pre"
/* The above line is to give proper line number references. Please mail me
 * if your compiler complains about it.
 */
/*
 * This is the grammar definition of LPC, and its code generator.
 *
 * NOTE: this is essentially the 3.1.1 version with 3.0.53-A3.1 fixes,
 *       but with MudOS support and lvalue lifetime bug fixes also patched
 *       in; hmm...it also appears some masochist reformatted this file...
 */

static void insert_pop_value PROT((void));

#ifdef LPC_OPTIMIZE_LOOPS
static int optimize_loop_cond PROT((char *e, int len));
static int optimize_while_dec PROT((char *e, int len));
#endif
static int last_expression = -1;

#define CURRENT_PROGRAM_SIZE (mem_block[current_block].current_size)

#define SET_CURRENT_PROGRAM_SIZE(x) \
        ( CURRENT_PROGRAM_SIZE = (x), last_expression = -1 )

#define LAST_EXPR_CODE (mem_block[current_block].block[last_expression])

typedef struct expr_s {
    char *expr;
    int len;
} expr_t;

/*
   these three variables used to properly adjust the 'break_sp' stack in
   the event a 'continue' statement is issued from inside a 'switch'.
*/
static short switches = 0;
static int switch_sptr = 0;
static int expr_sptr = 0;

static short switch_stack[SWITCH_STACK_SIZE];
static expr_t expr_stack[EXPR_STACK_SIZE];

static int current_break_address;
static int current_continue_address;
static int current_case_number_heap;
static int current_case_string_heap;
static int zero_case_label;

static int last_push_indexed;
static int last_push_local;
static int last_push_identifier;

static void epilog PROT((void));
static void prolog PROT((void));
static void clean_parser PROT((void));

static void add_to_case_heap PROT((int, struct case_heap_entry *));
static void push_switches PROT((void));
static void pop_switches PROT((void));
static void push_expression PROT((expr_t *));
static expr_t *pop_expression PROT((void));
static void free_expressions PROT((void));

static void start_initializer PROT((void));
static void end_initializer PROT((void));
static void ins_byte PROT((unsigned char));
static void upd_byte PROT((int, unsigned char));
static void ins_short PROT((short));
static void upd_short PROT((int, short));
static short read_short PROT((int));
static void ins_long PROT((int));
static void ins_real PROT((double));
INLINE static void ins_expr_f_byte PROT((unsigned int));
INLINE static void ins_f_byte PROT((unsigned int));
static void write_number PROT((int));
static int read_number PROT((int));
static float read_real PROT((int));
static short read_string PROT((int));

/*
 * bison & yacc don't prototype this in y.tab.h
 */
int yyparse PROT((void));

/*
 * Initialization code is now more compact.  It's collected in
 * A_INITIALIZER and put at the end of the program.  For compatibility,
 * there is a jump to it at address 0.
 */

static void start_initializer() {
  current_block = A_INITIALIZER;
}

static void end_initializer() {
  current_block = A_PROGRAM;
}

static void ins_byte P1(unsigned char, b)
{
    struct mem_block *mbp = &mem_block[current_block];
    if (mbp->current_size == mbp->max_size)
	realloc_mem_block(mbp, mbp->current_size + 1);
    mbp->block[mbp->current_size++] = b;
}

static void upd_byte P2(int, offset, unsigned char, b)
{
#ifdef DEBUG
    if (offset > CURRENT_PROGRAM_SIZE) {
	char buff[1024];

	sprintf(buff, "patch offset %x larger than current program size %x.\n",
	      offset, CURRENT_PROGRAM_SIZE);
	yyerror(buff);
    }
#endif
    mem_block[current_block].block[offset] = b;
}

/*
 * Store a 2 byte number. It is stored in such a way as to be sure
 * that correct byte order is used, regardless of machine architecture.
 * Also beware that some machines can't write a word to odd addresses.
 */
static void ins_short P1(short, l)
{
    struct mem_block *mbp = &mem_block[current_block];
    if (mbp->current_size + 2 > mbp->max_size)
	realloc_mem_block(mbp, mbp->current_size + 2);
    mbp->block[mbp->current_size++] = ((char *)&l)[0];
    mbp->block[mbp->current_size++] = ((char *)&l)[1];
}

static void upd_short P2(int, offset, short, l)
{
#ifdef DEBUG
    if (offset > CURRENT_PROGRAM_SIZE) {
	char buff[1024];

	sprintf(buff, "patch offset %x larger than current program size %x.\n",
	      offset, CURRENT_PROGRAM_SIZE);
	yyerror(buff);
    }
#endif
    mem_block[current_block].block[offset + 0] = ((char *)&l)[0];
    mem_block[current_block].block[offset + 1] = ((char *)&l)[1];
}

static short read_short P1(int, offset)
{
    short l;

    ((char *)&l)[0] = mem_block[current_block].block[offset + 0];
    ((char *)&l)[1] = mem_block[current_block].block[offset + 1];
    return l;
}

/*
 * Store a 4 byte number. It is stored in such a way as to be sure
 * that correct byte order is used, regardless of machine architecture.
 */
static void ins_long P1(int, l)
{
    struct mem_block *mbp = &mem_block[current_block];
    if (mbp->current_size + 4 > mbp->max_size)
	realloc_mem_block(mbp, mbp->current_size + 4);
    mbp->block[mbp->current_size++] = ((char *)&l)[0];
    mbp->block[mbp->current_size++] = ((char *)&l)[1];
    mbp->block[mbp->current_size++] = ((char *)&l)[2];
    mbp->block[mbp->current_size++] = ((char *)&l)[3];
}

static void ins_real P1(double, l)
{
    float f = (float)l;

    struct mem_block *mbp = &mem_block[current_block];
    if (mbp->current_size + 4 > mbp->max_size)
	realloc_mem_block(mbp, mbp->current_size + 4);
    mbp->block[mbp->current_size++] = ((char *)&f)[0];
    mbp->block[mbp->current_size++] = ((char *)&f)[1];
    mbp->block[mbp->current_size++] = ((char *)&f)[2];
    mbp->block[mbp->current_size++] = ((char *)&f)[3];
}

INLINE
static void ins_expr_f_byte P1(unsigned int, b)
{
    last_expression = CURRENT_PROGRAM_SIZE;
    if (b >= 0xff) {
	ins_byte((char)F_CALL_EXTRA);
	ins_byte((char)(b - 0xff));
    } else {
	ins_byte((char)b);
    }
}

INLINE
static void ins_f_byte P1(unsigned int, b)
{
    ins_expr_f_byte(b);
    last_expression = -1;
}

static void add_to_case_heap P2(int, block_index, struct case_heap_entry *, entry)
{
    char *heap_start;
    int offset,parent;
    int current_heap;

    if ( block_index == A_CASE_NUMBERS )
	current_heap = current_case_number_heap;
    else
	current_heap = current_case_string_heap;
    offset = mem_block[block_index].current_size - current_heap;
    add_to_mem_block(block_index, (char*)entry, sizeof(*entry) );
    heap_start = mem_block[block_index].block + current_heap;
    for ( ; offset; offset = parent ) {
	parent = ( offset - sizeof(struct case_heap_entry) ) >> 1 ;
	CASE_HEAP_ENTRY_ALIGN(parent);
	if ( ((struct case_heap_entry*)(heap_start+offset))->key <
	     ((struct case_heap_entry*)(heap_start+parent))->key ) {
	    *(struct case_heap_entry*)(heap_start+offset) =
	    *(struct case_heap_entry*)(heap_start+parent);
	    *(struct case_heap_entry*)(heap_start+parent) = *entry;
	}
    }
}

/*
 * Generate the code to push a number on the stack.
 * This varies since there are several opcodes (for
 * optimizing speed and/or size).
 */
static void write_number P1(int, val)
{
    if (val == 0) {
	ins_expr_f_byte(F_CONST0);
    } else if (val == 1) {
	ins_expr_f_byte(F_CONST1);
    } else if (val >= 0 && val < 256) {
	ins_f_byte(F_BYTE);
	ins_byte(val);
    } else if (val < 0 && val > -256) {
	ins_f_byte(F_NBYTE);
	ins_byte(-val);
    } else {
	ins_f_byte(F_NUMBER);
	ins_long(val);
    }
}

#ifdef LPC_OPTIMIZE

#define SIZEOF_ZERO_CODE 1   /* size of code to push 0 */

/* go through all the hassle of reading the number back out again */
static int read_number P1(int, address)
{
    int val;
    register char *block;

    block = &mem_block[current_block].block[address];
    switch(EXTRACT_UCHAR(block++)) {
    case F_CONST0:
	return 0;
    case F_CONST1:
	return 1;
    case F_BYTE:
	return EXTRACT_UCHAR(block);
    case F_NBYTE:
	return -((int)EXTRACT_UCHAR(block));
    case F_NUMBER:
	((char *)&val)[0] = block[0];
	((char *)&val)[1] = block[1];
	((char *)&val)[2] = block[2];
	((char *)&val)[3] = block[3];
	return val;
    default:
	yyerror("Internal error in read_number.");
    }
    return 0;
}

static float read_real P1(int, address)
{
    register char *block;
    block = &mem_block[current_block].block[address];
    if (EXTRACT_UCHAR(block++) == F_REAL) {
	float real;
	((char *)&real)[0] = block[0];
	((char *)&real)[1] = block[1];
	((char *)&real)[2] = block[2];
	((char *)&real)[3] = block[3];
	return real;
    } else {
	yyerror("Internal error in read_real.");
    }
    return 0.0;
}

static short read_string P1(int, address)
{
    register char *block;
    block = &mem_block[current_block].block[address];
    if (EXTRACT_UCHAR(block++) == F_STRING) {
	short num;
	((char *)&num)[0] = block[0];
	((char *)&num)[1] = block[1];
	return num;
    } else {
	yyerror("Internal error in read_string.");
    }
    return -1;
}
#endif

%}
