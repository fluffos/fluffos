#include "base/std.h"

#include "vm/internal/base/interpret.h"

#include <algorithm>
#include <functional>
#include <memory>
#include <string>
#include <vector>

#ifdef PACKAGE_PCRE
#include <pcre.h>
#endif

#include "applies_table.autogen.h"
#include "base/internal/lru_cache.h"
#include "base/internal/tracing.h"
#include "comm.h"  // add_vmessage FIXME: reverse API
#include "thirdparty/scope_guard/scope_guard.hpp"
#include "vm/internal/base/debug.h"
#include "vm/internal/apply.h"
#include "vm/internal/base/apply_cache.h"
#include "vm/internal/base/machine.h"
#include "vm/internal/eval_limit.h"
#include "vm/internal/master.h"
#include "vm/internal/simulate.h"
#include "vm/internal/simul_efun.h"
#include "compiler/internal/icode.h"  // for PUSH_WHAT
#include "compiler/internal/lex.h"    // for insstr, FIXME
#include "packages/core/sprintf.h"    // FIXME
#include "packages/core/regexp.h"     // FIXME
#include "packages/ops/ops.h"         // FIXME
#include "compiler/internal/disassembler.h"
#include "include/opcodes_extra.h"

extern int efun_arg_etypes[];  // in efuns.autogen.cc generated by make_func.y

int call_origin = 0;
error_context_t *current_error_context = nullptr;

static const char *type_names[] = {"int",      "string", "array",  "object", "mapping",
                                   "function", "float",  "buffer", "class"};
#define TYPE_CODES_END 0x400
#define TYPE_CODES_START 0x2

#ifdef PACKAGE_UIDS
extern struct userid_t *backbone_uid;
#endif
extern int call_origin;
static int find_line(char * /*p*/, const program_t * /*progp*/, const char ** /*ret_file*/,
                     int * /*ret_line*/);
void push_indexed_lvalue(int /*code*/);

void break_point(void);
static void do_loop_cond_number(void);
static void do_loop_cond_local(void);
static void do_catch(char * /*pc*/, unsigned short /*new_pc_offset*/);
int last_instructions(void);
static const char *get_arg(int, int);
extern inline const char *access_to_name(int /*mode*/);
extern inline const char *origin_to_name(int /*origin*/);

template <typename F>
void assign_lvalue_codepoint(F &&func);

static inline void replace_lvalue_with_value_on_stack(svalue_t *slot, const char *where) {
  svalue_t tmp;
  tmp.type = T_NUMBER;
  tmp.subtype = 0;
  tmp.u.number = 0;
  assign_svalue_no_free(&tmp, slot->u.lvalue);
  free_svalue(slot, where);
  assign_svalue_no_free(slot, &tmp);
  free_svalue(&tmp, where);
}

static inline void assign_value_to_lvalue(svalue_t *lval, svalue_t *value, const char *where) {
  switch (lval->type) {
    case T_LVALUE_BYTE: {
      if (value->type != T_NUMBER) {
        error("Illegal rhs to byte lvalue\n");
      }
      char c = static_cast<char>(value->u.number);

      if (global_lvalue_byte.subtype == 0 && c == '\0') {
        error("Strings cannot contain 0 bytes.\n");
      }
      *global_lvalue_byte.u.lvalue_byte = c;
      break;
    }
    case T_LVALUE_RANGE:
      assign_lvalue_range(value);
      break;
    case T_LVALUE_CODEPOINT: {
      if (value->type != T_NUMBER) {
        error("Illegal rhs to char lvalue\n");
      }
      UChar32 newc = value->u.number;
      assign_lvalue_codepoint([=](UChar32 /*unused*/) { return newc; });
      break;
    }
    default:
      assign_svalue(lval, value);
      break;
  }
}

#ifdef PACKAGE_PCRE
static inline bool use_pcre_sscanf() { return CONFIG_INT(__RC_SSCANF_USE_PCRE__); }

static bool pcre_sscanf_match(const char *pattern, int pattern_len, const char *subject,
                              bool anchored, const char **match_start, const char **match_end) {
  const char *compile_error = nullptr;
  int error_offset = 0;

  std::string pattern_str(pattern, pattern_len);
  pcre *re = pcre_compile(pattern_str.c_str(), anchored ? PCRE_ANCHORED : 0, &compile_error,
                          &error_offset, nullptr);
  if (!re) {
    error("PCRE compilation failed at offset %d: %s\n", error_offset, compile_error);
  }

  int capture_count = 0;
  pcre_fullinfo(re, nullptr, PCRE_INFO_CAPTURECOUNT, &capture_count);
  std::vector<int> ovector((capture_count + 1) * 3);

  int rc = pcre_exec(re, nullptr, subject, static_cast<int>(strlen(subject)), 0,
                     anchored ? PCRE_ANCHORED : 0, ovector.data(),
                     static_cast<int>(ovector.size()));
  if (rc < 0) {
    pcre_free(re);
    return false;
  }

  *match_start = subject + ovector[0];
  *match_end = subject + ovector[1];
  pcre_free(re);
  return true;
}
#else
static inline bool use_pcre_sscanf() { return false; }
#endif

#ifdef DEBUG
int stack_in_use_as_temporary = 0;
#endif

int inter_sscanf(svalue_t * /*arg*/, svalue_t * /*s0*/, svalue_t * /*s1*/, int /*num_arg*/);
program_t *current_prog;
short int caller_type;
int tracedepth;
int num_varargs;

/*
 * Inheritance:
 * An object X can inherit from another object Y. This is done with
 * the statement 'inherit "file";'
 * The inherit statement will clone a copy of that file, call reset
 * in it, and set a pointer to Y from X.
 * Y has to be removed from the linked list of all objects.
 * All variables declared by Y will be copied to X, so that X has access
 * to them.
 *
 * If Y isn't loaded when it is needed, X will be discarded, and Y will be
 * loaded separately. X will then be reloaded again.
 */

/*
 * These are the registers used at runtime.
 * The control stack saves registers to be restored when a function
 * will return. That means that control_stack[0] will have almost no
 * interesting values, as it will terminate execution.
 */
char *pc;     /* Program pointer. */
svalue_t *fp; /* Pointer to first argument. */

svalue_t *sp;

int function_index_offset; /* Needed for inheritance */
int variable_index_offset; /* Needed for inheritance */
int st_num_arg;

// For safety, we leave some buffer in before and after the space.
static svalue_t _stack[10 + CFG_EVALUATOR_STACK_SIZE + 10];
static svalue_t *const start_of_stack = &_stack[10];
svalue_t *const end_of_stack = start_of_stack + CFG_EVALUATOR_STACK_SIZE;

/* Used to throw an error to a catch */
svalue_t catch_value = {T_NUMBER};

// For safety, we leave some buffer in before and after the space.
control_stack_t _control_stack[5 + CFG_MAX_CALL_DEPTH + 5];
control_stack_t *const control_stack = &_control_stack[5];
control_stack_t *csp; /* Points to last element pushed */

int too_deep_error = 0, max_eval_error = 0;

ref_t *global_ref_list = nullptr;

void kill_ref(ref_t *ref) {
  if (ref->sv.type == T_MAPPING && (ref->sv.u.map->count & MAP_LOCKED)) {
    ref_t *r = global_ref_list;

    /* if some other ref references this mapping, it needs to remain
       locked */
    while (r) {
      if (r->sv.u.map == ref->sv.u.map) {
        break;
      }
      r = r->next;
    }
    if (!r) {
      ref->sv.u.map->count &= ~MAP_LOCKED;
    }
  }

  ref->next = freed_ref_list;
  freed_ref_list = ref;
}

#define SSCANF_ASSIGN_SVALUE_STRING(S) \
  arg->type = T_STRING;                \
  arg->u.string = S;                   \
  arg->subtype = STRING_MALLOC;        \
  arg--;                               \
  num_arg--

#define SSCANF_ASSIGN_SVALUE_NUMBER(N) \
  arg->type = T_NUMBER;                \
  arg->subtype = 0;                    \
  arg->u.number = N;                   \
  arg--;                               \
  num_arg--

#define SSCANF_ASSIGN_SVALUE(T, U, V) \
  arg->type = T;                      \
  arg->U = V;                         \
  arg--;                              \
  num_arg--

/* arg points to the same place it used to */
int inter_sscanf(svalue_t *arg, svalue_t *s0, svalue_t *s1, int num_arg) {
  const char *fmt;       /* Format description */
  const char *in_string; /* The string to be parsed. */
  int number_of_matches;
  int skipme; /* Encountered a '*' ? */
  int base = 10;
  LPC_INT num;
  const char *match;
  char old_char;
  const char *tmp;

  /*
   * First get the string to be parsed.
   */
  CHECK_TYPES(s0, T_STRING, 1, F_SSCANF);
  in_string = s0->u.string;

  /*
   * Now get the format description.
   */
  CHECK_TYPES(s1, T_STRING, 2, F_SSCANF);
  fmt = s1->u.string;

  /*
   * Loop for every % or substring in the format.
   */
  for (number_of_matches = 0; num_arg >= 0; number_of_matches++) {
    while (*fmt) {
      if (*fmt == '%') {
        if (*++fmt == '%') {
          if (*in_string++ != '%') {
            return number_of_matches;
          }
          fmt++;
          continue;
        }
        if (!*fmt) {
          error("Format string cannot end in '%%' in sscanf()\n");
        }
        break;
      }
      if (*fmt++ != *in_string++) {
        return number_of_matches;
      }
    }

    if (!*fmt) {
      /*
       * We have reached the end of the format string.  If there are
       * any chars left in the in_string, then we put them in the
       * last variable (if any).
       */
      if (*in_string && num_arg) {
        number_of_matches++;
        SSCANF_ASSIGN_SVALUE_STRING(string_copy(in_string, "sscanf"));
      }
      break;
    }
    DEBUG_CHECK(fmt[-1] != '%', "In sscanf, should be a %% now!\n");

    if ((skipme = (*fmt == '*'))) {
      fmt++;
    } else if (num_arg < 1 && *fmt != '%') {
      /*
       * Hmm ... maybe we should return number_of_matches here instead
       * of an error
       */
      error("Too few arguments to sscanf()\n");
    }

    switch (*fmt++) {
      case 'x':
        base = 16;
      /* fallthrough */
      case 'd': {
        LPC_INT tmp_num;

        tmp = in_string;
        tmp_num = strtoll(const_cast<char *>(in_string), const_cast<char **>(&in_string), base);
        if (tmp == in_string) {
          return number_of_matches;
        }
        if (!skipme) {
          SSCANF_ASSIGN_SVALUE_NUMBER(tmp_num);
        }
        base = 10;
        continue;
      }
      case 'f': {
        LPC_FLOAT tmp_num;

        tmp = in_string;
        tmp_num = strtod(const_cast<char *>(in_string), const_cast<char **>(&in_string));
        if (tmp == in_string) {
          return number_of_matches;
        }
        if (!skipme) {
          SSCANF_ASSIGN_SVALUE(T_REAL, u.real, tmp_num);
        }
        continue;
      }
      case '(': {
        tmp = fmt; /* 1 after the ( */
        num = 1;
        while (true) {
          switch (*tmp) {
            case '\\':
              if (*++tmp) {
                tmp++;
                continue;
              }
              // fall through
            case '\0':
              error("Bad regexp format: '%%%s' in sscanf format string\n", fmt);
            case '(':
              num++;
            /* FALLTHROUGH */
            default:
              tmp++;
              continue;
            case ')':
              if (!--num) {
                break;
              }
              tmp++;
              continue;
          }
          {
            int n = tmp - fmt;
#ifdef PACKAGE_PCRE
            if (use_pcre_sscanf()) {
              const char *match_start = nullptr;
              const char *match_end = nullptr;
              if (!pcre_sscanf_match(fmt, n, in_string, /*anchored*/ true, &match_start,
                                     &match_end)) {
                return number_of_matches;
              }
              if (!skipme) {
                int len = match_end - match_start;
                char *buf = new_string(len, "sscanf pcre regexp return");
                memcpy(buf, match_start, len);
                buf[len] = 0;
                SSCANF_ASSIGN_SVALUE_STRING(buf);
              }
              in_string = match_end;
              fmt = ++tmp;
              break;
            }
#endif
            struct regexp *reg;
            char *buf = reinterpret_cast<char *>(DMALLOC(n + 1, TAG_TEMPORARY, "sscanf regexp"));
            memcpy(buf, fmt, n);
            buf[n] = 0;
            regexp_user = EFUN_REGEXP;
            reg = regcomp(reinterpret_cast<unsigned char *>(buf), 0);
            FREE(buf);
            if (!reg) {
              error(regexp_error);
            }
            if (!regexec(reg, in_string) || (in_string != reg->startp[0])) {
              FREE(reg);
              return number_of_matches;
            }
            if (!skipme) {
              n = *reg->endp - in_string;
              buf = new_string(n, "sscanf regexp return");
              memcpy(buf, in_string, n);
              buf[n] = 0;
              SSCANF_ASSIGN_SVALUE_STRING(buf);
            }
            in_string = *reg->endp;
            FREE((char *)reg);
            fmt = ++tmp;
            break;
          }
        }
        continue;
      }
      case 's':
        break;
      default:
        error("Bad type : '%%%c' in sscanf() format string\n", fmt[-1]);
    }

    /*
     * Now we have the string case.
     */

    /*
     * First case: There were no extra characters to match. Then this is
     * the last match.
     */
    if (!*fmt) {
      number_of_matches++;
      if (!skipme) {
        SSCANF_ASSIGN_SVALUE_STRING(string_copy(in_string, "sscanf"));
      }
      break;
    }
    /*
     * If the next char in the format string is a '%' then we have to do
     * some special checks. Only %d, %f, %x, %(regexp) and %% are allowed
     * after a %s
     */
    if (*fmt++ == '%') {
      int skipme2;

      tmp = in_string;
      if ((skipme2 = (*fmt == '*'))) {
        fmt++;
      }
      if (num_arg < (!skipme + !skipme2) && *fmt != '%') {
        error("Too few arguments to sscanf().\n");
      }

      number_of_matches++;

      switch (*fmt++) {
        case 's':
          error(
              "Illegal to have 2 adjacent %%s's in format string in "
              "sscanf()\n");
        case 'x':
          do {
            while (*tmp && (*tmp != '0')) {
              tmp++;
            }
            if (*tmp == '0') {
              if ((tmp[1] == 'x' || tmp[1] == 'X') && uisxdigit(tmp[2])) {
                break;
              }
              tmp += 2;
            }
          } while (*tmp);
          break;
        case 'd':
          while (*tmp && !uisdigit(*tmp)) {
            tmp++;
          }
          break;
        case 'f':
          while (*tmp && !uisdigit(*tmp) && (*tmp != '.' || !uisdigit(tmp[1]))) {
            tmp++;
          }
          break;
        case '%':
          while (*tmp && (*tmp != '%')) {
            tmp++;
          }
          number_of_matches--;
          break;
        case '(': {
          tmp = fmt;
          num = 1;
          while (true) {
            switch (*tmp) {
              case '\\':
                if (*++tmp) {
                  tmp++;
                  continue;
                }
                // fall through
              case '\0':
                error("Bad regexp format : '%%%s' in sscanf format string\n", fmt);
              case '(':
                num++;
              /* FALLTHROUGH */
              default:
                tmp++;
                continue;

              case ')':
                if (!--num) {
                  break;
                }
                tmp++;
                continue;
            }
            {
              int n = tmp - fmt;
#ifdef PACKAGE_PCRE
              if (use_pcre_sscanf()) {
                const char *match_start = nullptr;
                const char *match_end = nullptr;
                if (!pcre_sscanf_match(fmt, n, in_string, /*anchored*/ false, &match_start,
                                       &match_end)) {
                  if (!skipme) {
                    SSCANF_ASSIGN_SVALUE_STRING(string_copy(in_string, "sscanf"));
                  }
                  return number_of_matches;
                }
                if (!skipme) {
                  int prefix_len = match_start - in_string;
                  char *tmp2 = new_string(prefix_len, "inter_sscanf");
                  memcpy(tmp2, in_string, prefix_len);
                  tmp2[prefix_len] = 0;
                  match = tmp2;
                  SSCANF_ASSIGN_SVALUE_STRING(match);
                }
                in_string = match_end;
                if (!skipme2) {
                  int match_len = match_end - match_start;
                  char *tmp2 = new_string(match_len, "inter_sscanf");
                  memcpy(tmp2, match_start, match_len);
                  tmp2[match_len] = 0;
                  match = tmp2;
                  SSCANF_ASSIGN_SVALUE_STRING(match);
                }
                fmt = ++tmp;
                break;
              }
#endif
              struct regexp *reg;
              char *buf = reinterpret_cast<char *>(DMALLOC(n + 1, TAG_TEMPORARY, "sscanf regexp"));
              memcpy(buf, fmt, n);
              buf[n] = 0;
              regexp_user = EFUN_REGEXP;
              reg = regcomp(reinterpret_cast<unsigned char *>(buf), 0);
              FREE(buf);
              if (!reg) {
                error(regexp_error);
              }
              if (!regexec(reg, in_string)) {
                if (!skipme) {
                  SSCANF_ASSIGN_SVALUE_STRING(string_copy(in_string, "sscanf"));
                }
                FREE((char *)reg);
                return number_of_matches;
              } else {
                if (!skipme) {
                  char *tmp2 = new_string(num = (*reg->startp - in_string), "inter_sscanf");
                  memcpy(tmp2, in_string, num);
                  tmp2[num] = 0;
                  match = tmp2;
                  SSCANF_ASSIGN_SVALUE_STRING(match);
                }
                in_string = *reg->endp;
                if (!skipme2) {
                  char *tmp2 = new_string(num = (*reg->endp - *reg->startp), "inter_sscanf");
                  memcpy(tmp2, *reg->startp, num);
                  tmp2[num] = 0;
                  match = tmp2;
                  SSCANF_ASSIGN_SVALUE_STRING(match);
                }
                FREE((char *)reg);
              }
              fmt = ++tmp;
              break;
            }
          }
          continue;
        }

        case 0:
          error("Format string can't end in '%%'.\n");
        default:
          error("Bad type : '%%%c' in sscanf() format string\n", fmt[-1]);
      }

      if (!skipme) {
        char *tmp2 = new_string(num = (tmp - in_string), "inter_sscanf");
        memcpy(tmp2, in_string, num);
        tmp2[num] = 0;
        match = tmp2;
        SSCANF_ASSIGN_SVALUE_STRING(match);
      }
      if (!*(in_string = tmp)) {
        return number_of_matches;
      }
      switch (fmt[-1]) {
        case 'x':
          base = 16;
          // fall through
        case 'd': {
          num = strtoll(const_cast<char *>(in_string), const_cast<char **>(&in_string), base);
          /* We already knew it would be matched - Sym */
          if (!skipme2) {
            SSCANF_ASSIGN_SVALUE_NUMBER(num);
          }
          base = 10;
          continue;
        }
        case 'f': {
          LPC_FLOAT tmp_num =
              strtod(const_cast<char *>(in_string), const_cast<char **>(&in_string));
          if (!skipme2) {
            SSCANF_ASSIGN_SVALUE(T_REAL, u.real, tmp_num);
          }
          continue;
        }
        case '%':
          in_string++;
          continue; /* on the big for loop */
      }
    }
    if ((tmp = strchr(fmt, '%')) != nullptr) {
      num = tmp - fmt + 1;
    } else {
      tmp = fmt + (num = strlen(fmt));
      num++;
    }

    old_char = *--fmt;
    match = in_string;

    /* This loop would be even faster if it used replace_string's skiptable
       algorithm.  Maybe that algorithm should be lifted so it can be
       used in strsrch as well has here, etc? */
    while (*in_string) {
      if ((*in_string == old_char) && !strncmp(in_string, fmt, num)) {
        /*
         * Found a match !
         */
        if (!skipme) {
          char *newmatch;

          newmatch = new_string(skipme = (in_string - match), "inter_sscanf");
          memcpy(newmatch, match, skipme);
          newmatch[skipme] = 0;
          SSCANF_ASSIGN_SVALUE_STRING(newmatch);
        }
        in_string += num;
        fmt = tmp; /* advance fmt to next % */
        break;
      }
      in_string++;
    }
    if (fmt == tmp) { /* If match, then do continue. */
      continue;
    }

    /*
     * No match was found. Then we stop here, and return the result so
     * far !
     */
    break;
  }
  return number_of_matches;
}

/*
 * Reset the virtual stack machine.
 */
void reset_machine(int first) {
  csp = control_stack - 1;
  if (first) {
    sp = start_of_stack - 1;
  } else {
    pop_n_elems(sp - start_of_stack + 1);
#ifdef DEBUG
    stack_in_use_as_temporary = 0;
#endif
  }
}

static const char *get_arg(int a, int b) {
  static char buff[50];
  char *from, *to;

  from = previous_pc[a];
  to = previous_pc[b];
  if (to - from < 2) {
    return "";
  }
  if (to - from == 2) {
    sprintf(buff, "%d", from[1]);
    return buff;
  }
  if (to - from == 3) {
    short arg;

    COPY_SHORT(&arg, from + 1);
    sprintf(buff, "%d", arg);
    return buff;
  }
  fatal("get_arg: args longer than 3 not supported.\n");
  return nullptr; /* to keep some compilers happy */
}
